import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.border.EmptyBorder;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;

public class Pong extends JPanel implements KeyListener, ActionListener {
    private int paddle1Y = 160, paddle2Y = 160;
    private int paddle1X = 16, paddle2X = 992;
    private int ballX = 480, ballY = 272;
    private double ballDirX = -7, ballDirY = 7;
    private final int PADDLE_WIDTH = 16, PADDLE_HEIGHT = 64;
    private final int BALL_SIZE = 16;
    private int score1 = 0, score2 = 0;
    private int sets1 = 0, sets2 = 0;
    private Timer timer;
    private double speedMultiplier = 1.17;
    private final int SCORE_LIMIT = 5; // Limite goles
    private final int SET_LIMITE = 3;
    private final int GAME_TIME = 120; // Tiempo en segundos
    private long startTime;
    private boolean gameOver = false; // Nueva bandera para controlar el estado del juego
    
    private boolean inverso = false;

    // Movement flags
    private boolean upPressed = false, downPressed = false;
    private boolean wPressed = false, sPressed = false;

    public Pong() {
        setPreferredSize(new Dimension(1024, 576)); 
        setBackground(new Color(63,113,146));
        setFocusable(true);
        addKeyListener(this);
        timer = new Timer(20, this); 
        timer.start();

        startTime = System.currentTimeMillis(); // Iniciar juego

        JFrame frame = new JFrame("Pong Game");
        frame.add(this);
        frame.pack();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }

    private void resetGame() {
        paddle1Y = 256; 
        paddle2Y = 256;
        ballX = 512;
        ballY = 288;
        score1 = 0;
        score2 = 0;
        ballDirX = -7; // Dirección inicial de la pelota
        ballDirY = 7;
        speedMultiplier = 1.17; // Reiniciar multiplicador de velocidad
        startTime = System.currentTimeMillis(); // Reiniciar tiempo de juego
        gameOver = false; // Reiniciar estado del juego
        repaint();
    }

    public void paintComponent(Graphics g) {
        super.paintComponent(g);

        Graphics2D g2d = (Graphics2D) g;

        // LINEA MEDIO
        g2d.setStroke(new BasicStroke(2));
        g.setColor(Color.WHITE);
        g.drawLine(0, 288, 1024, 288);
        
        // Draw middle dotted line
        drawDottedLine(g2d, 512, 0, 512, getHeight());
        
        // Draw left paddle (Player 1)
        g.setColor(new Color(240,76,49));
        g.fillRect(paddle1X, paddle1Y, PADDLE_WIDTH, PADDLE_HEIGHT); //16

        // Draw right paddle (Player 2)
        g.setColor(new Color(40,66,166));
        g.fillRect(paddle2X, paddle2Y, PADDLE_WIDTH, PADDLE_HEIGHT); //992

        // Draw ball
        g.setColor(new Color(237,195,49));
        g.fillOval(ballX, ballY, BALL_SIZE, BALL_SIZE);

        // Draw scores
        g.setColor(Color.red);
        drawScore(g, score1, 256, 48);
        g.setColor(Color.blue);
        drawScore(g, score2, 768, 48);
        
        g.setColor(Color.WHITE);
        drawScore(g, sets1, 231, 48);
        drawScore(g, sets2, 793, 48);

        // Draw remaining time
        long elapsedTime = (System.currentTimeMillis() - startTime) / 1000;
        long remainingTime = GAME_TIME - elapsedTime;
        if (remainingTime > 0 && !gameOver) {
            g.setFont(new Font("Monospaced", Font.BOLD, 36)); // Aumentar tamaño de fuente
            String timeText = "" + remainingTime + "";
            FontMetrics metrics = g.getFontMetrics();
            int textWidth = metrics.stringWidth(timeText);
            int textHeight = metrics.getAscent();
            int rectWidth = textWidth + 30; // Ancho del recuadro
            int rectHeight = textHeight + 20; // Altura del recuadro
            
            // Centro el recuadro
            int x = getWidth() / 2 - rectWidth / 2;
            int y = 20;

            // Dibuja el recuadro relleno negro más cercano al gris y opaco
            g.setColor(new Color(255, 255, 255, 100)); // Negro más cercano al gris y opaco
            g.fillRect(x, y, rectWidth, rectHeight);
            
            // Dibuja el texto en rojo
            g.setColor(new Color(237,195,49));
            g.drawString(timeText, x + 15, y + textHeight + 10);
        } else if (!gameOver) {
            gameOver = true; // Finalizar el juego
            repaint();
        } else {
            drawGameOverScreen(g);
        }
    }

    private void drawDottedLine(Graphics2D g2d, int x1, int y1, int x2, int y2) {
        int segmentWidth = 10; // Ancho de cada segmento
        int segmentHeight = 2; // Grosor de la línea
        int dashLength = 5;   // Longitud de cada segmento
        int gapLength = 0;    // Espaciado entre segmentos

        g2d.setStroke(new BasicStroke(segmentHeight, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL));
        
        Color color1 = Color.DARK_GRAY;
        Color color2 = Color.WHITE;

        int length = y2 - y1;
        int currentY = y1;
        boolean drawColor1 = true;

        while (currentY < y2) {
            g2d.setColor(drawColor1 ? color1 : color2);
            int nextY = Math.min(currentY + dashLength, y2);
            g2d.drawLine(x1, currentY, x1, nextY);
            currentY = nextY + gapLength;
            drawColor1 = !drawColor1;
        }
    }

    private void drawScore(Graphics g, int score, int x, int y) {
        g.setFont(new Font("Monospaced", Font.BOLD, 32));
        g.drawString(String.valueOf(score), x, y);
    }

    public void actionPerformed(ActionEvent e) {
        if (gameOver) return; // No actualizar si el juego está terminado

        ballX += ballDirX;
        ballY += ballDirY;

        // Colisión con los bordes superior e inferior
        if (ballY <= 0 || ballY >= getHeight() - BALL_SIZE) {
            ballDirY = -ballDirY;
        }

        // Colisión con la paleta izquierda (Jugador 1)
        if (ballX <= (paddle1X + PADDLE_WIDTH) && 
            ballX + BALL_SIZE >= paddle1X &&
            ballY + BALL_SIZE >= paddle1Y &&
            ballY <= paddle1Y + PADDLE_HEIGHT) {
            ballDirX = -ballDirX;
            increaseBallSpeed();
        }

        // Colisión con la paleta derecha (Jugador 2)
        if (ballX + BALL_SIZE >= paddle2X && 
            ballX <= (paddle2X + PADDLE_WIDTH) &&
            ballY + BALL_SIZE >= paddle2Y &&
            ballY <= paddle2Y + PADDLE_HEIGHT) {
            ballDirX = -ballDirX;
            increaseBallSpeed();
        }

        // Verificación de puntuación
        if (ballX < 0) {
            score2++;
            if (score2 == SCORE_LIMIT) {
            	score2 = 0;
                sets2++;
                if (sets2 >= SET_LIMITE) {
                    gameOver = true;
                } else {
                    // Invertir lados y reiniciar el juego para el siguiente set
                    invertPlayers();
                    resetBall(true);
                }
            } else {
                resetBall(true); // Cambiar la dirección de la pelota
            }
        } else if (ballX > getWidth()) {
            score1++;
            if (score1 == SCORE_LIMIT) {
            	score1 = 0;
                sets1++;
                if (sets1 >= SET_LIMITE) {
                    gameOver = true;
                } else {
                    // Invertir lados y reiniciar el juego para el siguiente set
                    invertPlayers();
                    resetBall(false);
                }
            } else {
                resetBall(false); // Cambiar la dirección de la pelota
            }
        }

        // Movimiento de las paletas
        if (wPressed && paddle1Y > 0) {
            paddle1Y -= 8;
        }
        if (sPressed && paddle1Y < getHeight() - PADDLE_HEIGHT) {
            paddle1Y += 8;
        }
        if (upPressed && paddle2Y > 0) {
            paddle2Y -= 8;
        }
        if (downPressed && paddle2Y < getHeight() - PADDLE_HEIGHT) {
            paddle2Y += 8;
        }

        repaint();
    }



    private void resetBall(boolean changeDirection) {
        ballX = 512;
        ballY = 288;
        ballDirY = (ballDirY < 0 ? -7 : 7); // Mantener la dirección vertical
        ballDirX = changeDirection ? -7 : 7; // Cambiar la dirección horizontal
        speedMultiplier = 1.17;
    }



    private void increaseBallSpeed() {
        ballDirX *= speedMultiplier;
        ballDirY *= speedMultiplier;
    }
    
    private void drawGameOverScreen(Graphics g) {
        if (score1 > score2) {
            g.setColor(new Color(40,66,166,120));
            g.fillRect(0, 0, getWidth(), getHeight());
        	
            g.setColor(new Color(240,76,49)); // Color para jugador 1
        } else if(score2 > score1) {
            g.setColor(new Color(240,76,49,120));
            g.fillRect(0, 0, getWidth(), getHeight());
            
            g.setColor(new Color(40,66,166)); // Color para jugador 2
        } else if(score1 == score2) {
            g.setColor(new Color(0,0,0,120));
            g.fillRect(0, 0, getWidth(), getHeight());
            
            g.setColor(new Color(255,255,255)); // Color para empate
        }
        
        g.setFont(new Font("Monospaced", Font.BOLD, 36));
        FontMetrics metrics = g.getFontMetrics();
        String winnerText = (score1 > score2) ? "Jugador 1 Gana" : (score2 > score1) ? "Jugador 2 Gana" : "Empate";
        int textWidth = metrics.stringWidth(winnerText);
        int textHeight = metrics.getAscent();
        int x = (getWidth() - textWidth) / 2;
        int y = (getHeight() - textHeight) / 2 - 10;
        
        g.drawString(winnerText, x, y);
        g.setFont(new Font("Monospaced", Font.BOLD, 30));
        g.drawString("Presione R para reiniciar el juego", getWidth() / 2 - 270, getHeight() / 2 + 30);
    }
    
    public void keyPressed(KeyEvent e) {
        int key = e.getKeyCode();
        if (key == KeyEvent.VK_W) {
            wPressed = true;
        }
        if (key == KeyEvent.VK_S) {
            sPressed = true;
        }
        if (key == KeyEvent.VK_UP) {
            upPressed = true;
        }
        if (key == KeyEvent.VK_DOWN) {
            downPressed = true;
        }
        if (key == KeyEvent.VK_R && gameOver) {
            resetGame();
        }
    }

    public void keyReleased(KeyEvent e) {
        int key = e.getKeyCode();
        if (key == KeyEvent.VK_W) {
            wPressed = false;
        }
        if (key == KeyEvent.VK_S) {
            sPressed = false;
        }
        if (key == KeyEvent.VK_UP) {
            upPressed = false;
        }
        if (key == KeyEvent.VK_DOWN) {
            downPressed = false;
        }
    }

    public void keyTyped(KeyEvent e) {}

    public static void main(String[] args) {
        SwingUtilities.invokeLater(Pong::new);
    }
    
    private void invertPlayers() {
        int temp = paddle1X;
        paddle1X = paddle2X;
        paddle2X = temp;
        inverso = !inverso;
    }


}